# FMTC çˆ¬è™«ç³»ç»Ÿæ¶æ„æ·±åº¦åˆ†æ

## ğŸ“‹ ç›®å½•

1. [è®¾è®¡å†³ç­–åˆ†æ](#è®¾è®¡å†³ç­–åˆ†æ)
2. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
3. [æ‰©å±•æ€§è®¾è®¡](#æ‰©å±•æ€§è®¾è®¡)
4. [æŠ€æœ¯é€‰å‹åŸç†](#æŠ€æœ¯é€‰å‹åŸç†)
5. [ç³»ç»Ÿé™åˆ¶ä¸è¾¹ç•Œ](#ç³»ç»Ÿé™åˆ¶ä¸è¾¹ç•Œ)
6. [å®‰å…¨æ€§è®¾è®¡](#å®‰å…¨æ€§è®¾è®¡)
7. [ç›‘æ§ä¸å¯è§‚æµ‹æ€§](#ç›‘æ§ä¸å¯è§‚æµ‹æ€§)
8. [å®¹é”™ä¸æ¢å¤æœºåˆ¶](#å®¹é”™ä¸æ¢å¤æœºåˆ¶)

## è®¾è®¡å†³ç­–åˆ†æ

### ğŸ¯ åŒçˆ¬è™«æ¨¡å¼çš„è®¾è®¡ç†å¿µ

#### é—®é¢˜èƒŒæ™¯

åœ¨FMTCçˆ¬è™«ç³»ç»Ÿçš„è®¾è®¡åˆæœŸï¼Œé¢ä¸´ä¸€ä¸ªæ ¸å¿ƒçŸ›ç›¾ï¼š

- **å‡†ç¡®æ€§éœ€æ±‚**: è°ƒè¯•å’Œå°è§„æ¨¡æŠ“å–éœ€è¦è¯¦ç»†çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€è·Ÿè¸ª
- **æ•ˆç‡éœ€æ±‚**: ç”Ÿäº§ç¯å¢ƒå¤§è§„æ¨¡æ•°æ®åŒæ­¥éœ€è¦é«˜å¹¶å‘å’Œå¿«é€Ÿå¤„ç†

ä¼ ç»Ÿçš„å•ä¸€çˆ¬è™«è®¾è®¡éš¾ä»¥åŒæ—¶æ»¡è¶³è¿™ä¸¤ç§éœ€æ±‚ï¼Œå› æ­¤åˆ›æ–°æ€§åœ°é‡‡ç”¨äº†**åŒçˆ¬è™«æ¨¡å¼**ã€‚

#### æ¶æ„å†³ç­–çŸ©é˜µ

| è®¾è®¡ç»´åº¦     | å•ä¸€å•†æˆ·çˆ¬è™«           | æ‰¹é‡å•†æˆ·çˆ¬è™«       | è®¾è®¡ç†ç”±           |
| ------------ | ---------------------- | ------------------ | ------------------ |
| **ç›®æ ‡åœºæ™¯** | è°ƒè¯•ã€æµ‹è¯•ã€ç²¾ç¡®æŠ“å–   | ç”Ÿäº§ç¯å¢ƒã€æ‰¹é‡åŒæ­¥ | åœºæ™¯åˆ†ç¦»ï¼Œå„è‡ªä¼˜åŒ– |
| **å¹¶å‘æ¨¡å¼** | å•çº¿ç¨‹é¡ºåºæ‰§è¡Œ         | å¤šå·¥ä½œçº¿ç¨‹å¹¶å‘     | è°ƒè¯•vsæ•ˆç‡çš„æƒè¡¡   |
| **é”™è¯¯å¤„ç†** | è¯¦ç»†è®°å½•ï¼Œæ”¯æŒä¸­æ–­æ¢å¤ | å¿«é€Ÿè·³è¿‡ï¼Œæ•´ä½“ç»Ÿè®¡ | å¯é æ€§vsæ€§èƒ½æƒè¡¡   |
| **ä¼šè¯ç®¡ç†** | æ¯æ¬¡ç‹¬ç«‹ç™»å½•           | ä¼šè¯å¤ç”¨å…±äº«       | å®‰å…¨æ€§vsæ•ˆç‡æƒè¡¡   |
| **æ—¥å¿—ç­–ç•¥** | è¯¦ç»†è°ƒè¯•æ—¥å¿—           | å…³é”®äº‹ä»¶æ—¥å¿—       | å¯è°ƒè¯•æ€§vsæ€§èƒ½æƒè¡¡ |
| **ç”¨æˆ·äº¤äº’** | æ”¯æŒæ‰‹åŠ¨ä»‹å…¥           | å®Œå…¨è‡ªåŠ¨åŒ–         | çµæ´»æ€§vsè‡ªåŠ¨åŒ–æƒè¡¡ |

#### è®¾è®¡æ¨¡å¼åº”ç”¨

```mermaid
graph TB
    A[çˆ¬è™«éœ€æ±‚] --> B{åœºæ™¯è¯†åˆ«}

    B -->|è°ƒè¯•/æµ‹è¯•åœºæ™¯| C[å•ä¸€å•†æˆ·çˆ¬è™«]
    B -->|ç”Ÿäº§/æ‰¹é‡åœºæ™¯| D[æ‰¹é‡å•†æˆ·çˆ¬è™«]

    C --> E[Strategy Pattern<br/>è¯¦ç»†ç­–ç•¥]
    D --> F[Strategy Pattern<br/>é«˜æ•ˆç­–ç•¥]

    E --> G[Template Method<br/>æ ‡å‡†æµç¨‹]
    F --> G

    G --> H[Factory Pattern<br/>å®ä¾‹åˆ›å»º]

    subgraph "å…±äº«ç»„ä»¶"
        I[ä¼šè¯ç®¡ç†å™¨]
        J[åæ£€æµ‹æ¨¡å—]
        K[æ•°æ®è§£æå™¨]
    end

    C --> I
    D --> I
    C --> J
    D --> J
    C --> K
    D --> K
```

**åº”ç”¨çš„è®¾è®¡æ¨¡å¼**:

1. **ç­–ç•¥æ¨¡å¼ (Strategy Pattern)**: ä¸¤ç§çˆ¬è™«å®ç°ç›¸åŒæ¥å£ï¼Œå¯äº’æ¢ä½¿ç”¨
2. **æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method)**: å®šä¹‰ç»Ÿä¸€çš„æŠ“å–æµç¨‹æ¡†æ¶
3. **å·¥å‚æ¨¡å¼ (Factory Pattern)**: æ ¹æ®é…ç½®åŠ¨æ€åˆ›å»ºåˆé€‚çš„çˆ¬è™«å®ä¾‹
4. **é—¨é¢æ¨¡å¼ (Facade Pattern)**: ç»Ÿä¸€çš„APIå…¥å£éšè—å†…éƒ¨å¤æ‚æ€§

### ğŸ”„ ä¼šè¯ç®¡ç†æ¶æ„å†³ç­–

#### ä¼ ç»Ÿæ–¹æ¡ˆ vs è‡ªç ”æ–¹æ¡ˆ

| å¯¹æ¯”ç»´åº¦       | ä¼ ç»ŸCookieå­˜å‚¨ | è‡ªç ”ä¼šè¯ç®¡ç†å™¨     | å†³ç­–ç†ç”±       |
| -------------- | -------------- | ------------------ | -------------- |
| **æŒä¹…åŒ–æ–¹å¼** | æµè§ˆå™¨å†…å­˜     | æ–‡ä»¶ç³»ç»ŸåŠ å¯†å­˜å‚¨   | è·¨è¿›ç¨‹å…±äº«éœ€æ±‚ |
| **ä¼šè¯å…±äº«**   | ä¸æ”¯æŒ         | å¤šå®ä¾‹å…±äº«         | æ‰¹é‡çˆ¬è™«éœ€æ±‚   |
| **è¿‡æœŸç®¡ç†**   | æµè§ˆå™¨è‡ªåŠ¨     | è‡ªå®šä¹‰TTLç­–ç•¥      | ä¸šåŠ¡å®šåˆ¶éœ€æ±‚   |
| **å®‰å…¨æ€§**     | åŸºç¡€ä¿æŠ¤       | AESåŠ å¯†+å®Œæ•´æ€§æ ¡éªŒ | æ•æ„Ÿæ•°æ®ä¿æŠ¤   |
| **è°ƒè¯•èƒ½åŠ›**   | æœ‰é™           | è¯¦ç»†çŠ¶æ€è·Ÿè¸ª       | å¼€å‘è°ƒè¯•éœ€æ±‚   |

#### ä¼šè¯ç®¡ç†å™¨è®¾è®¡

```typescript
interface SessionManager {
  // æ ¸å¿ƒä¼šè¯æ“ä½œ
  saveSession(page: Page): Promise<void>;
  restoreSession(page: Page): Promise<boolean>;

  // é«˜çº§ä¼šè¯ç®¡ç†
  validateSession(page: Page): Promise<boolean>;
  refreshSession(page: Page): Promise<void>;
  clearSession(): Promise<void>;

  // å¹¶å‘å®‰å…¨æ”¯æŒ
  acquireLock(key: string): Promise<SessionLock>;
  releaseLock(lock: SessionLock): Promise<void>;

  // ç›‘æ§å’Œè¯Šæ–­
  getSessionMetrics(): SessionMetrics;
  exportSessionData(): Promise<SessionExport>;
}

class FMTCSessionManager implements SessionManager {
  private readonly lockManager: LockManager;
  private readonly encryption: EncryptionService;
  private readonly metrics: MetricsCollector;

  constructor(config: SessionConfig) {
    this.lockManager = new FileLockManager(config.lockDir);
    this.encryption = new AESEncryptionService(config.encryptionKey);
    this.metrics = new SessionMetricsCollector();
  }

  /**
   * ä¿å­˜ä¼šè¯çŠ¶æ€çš„å®Œæ•´å®ç°
   */
  async saveSession(page: Page): Promise<void> {
    const lock = await this.lockManager.acquire(`session-${this.sessionId}`);

    try {
      // 1. æ”¶é›†ä¼šè¯æ•°æ®
      const sessionData = await this.collectSessionData(page);

      // 2. éªŒè¯æ•°æ®å®Œæ•´æ€§
      const isValid = await this.validateSessionData(sessionData);
      if (!isValid) {
        throw new Error("ä¼šè¯æ•°æ®éªŒè¯å¤±è´¥");
      }

      // 3. åŠ å¯†æ•æ„Ÿæ•°æ®
      const encryptedData = await this.encryption.encrypt(sessionData);

      // 4. åŸå­æ€§å†™å…¥æ–‡ä»¶
      await this.atomicWrite(this.sessionFile, encryptedData);

      // 5. æ›´æ–°å…ƒæ•°æ®
      await this.updateSessionMetadata({
        savedAt: new Date(),
        ttl: this.config.maxAge,
        checksum: this.calculateChecksum(encryptedData),
      });

      // 6. è®°å½•æŒ‡æ ‡
      this.metrics.recordSessionSave(sessionData.size, Date.now() - startTime);
    } finally {
      await this.lockManager.release(lock);
    }
  }

  /**
   * æ™ºèƒ½ä¼šè¯æ¢å¤é€»è¾‘
   */
  async restoreSession(page: Page): Promise<boolean> {
    try {
      // 1. æ£€æŸ¥ä¼šè¯æ–‡ä»¶å­˜åœ¨æ€§
      if (!(await this.sessionFileExists())) {
        return false;
      }

      // 2. éªŒè¯ä¼šè¯æœªè¿‡æœŸ
      const metadata = await this.getSessionMetadata();
      if (this.isSessionExpired(metadata)) {
        await this.clearExpiredSession();
        return false;
      }

      // 3. è¯»å–å¹¶è§£å¯†ä¼šè¯æ•°æ®
      const encryptedData = await this.readSessionFile();
      const sessionData = await this.encryption.decrypt(encryptedData);

      // 4. éªŒè¯æ•°æ®å®Œæ•´æ€§
      if (!(await this.validateSessionIntegrity(sessionData, metadata))) {
        await this.clearCorruptedSession();
        return false;
      }

      // 5. æ¢å¤æµè§ˆå™¨çŠ¶æ€
      await this.restoreBrowserState(page, sessionData);

      // 6. éªŒè¯ä¼šè¯æœ‰æ•ˆæ€§
      const isSessionValid = await this.validateRestoredSession(page);
      if (!isSessionValid) {
        return false;
      }

      // 7. è®°å½•æˆåŠŸæŒ‡æ ‡
      this.metrics.recordSessionRestore(true, sessionData.age);
      return true;
    } catch (error) {
      this.metrics.recordSessionRestore(false, 0);
      await this.handleSessionRestoreError(error);
      return false;
    }
  }
}
```

### ğŸ“Š æ•°æ®ä¸€è‡´æ€§è®¾è®¡

#### åˆ†å¸ƒå¼æ•°æ®ä¸€è‡´æ€§æŒ‘æˆ˜

FMTCçˆ¬è™«ç³»ç»Ÿåœ¨å¤„ç†å¤§è§„æ¨¡æ•°æ®æ—¶é¢ä¸´çš„ä¸€è‡´æ€§æŒ‘æˆ˜ï¼š

1. **å¹¶å‘å†™å…¥**: å¤šä¸ªçˆ¬è™«å®ä¾‹åŒæ—¶æ›´æ–°åŒä¸€å•†æˆ·æ•°æ®
2. **éƒ¨åˆ†å¤±è´¥**: æ‰¹é‡æ“ä½œä¸­éƒ¨åˆ†å•†æˆ·æ›´æ–°å¤±è´¥
3. **é‡å¤æ•°æ®**: ç½‘ç»œå¼‚å¸¸å¯¼è‡´çš„é‡å¤æäº¤
4. **ç‰ˆæœ¬å†²çª**: åŒä¸€æ•°æ®çš„å¹¶å‘ä¿®æ”¹å†²çª

#### è§£å†³æ–¹æ¡ˆï¼šäº‹åŠ¡æ€§æ•°æ®å¤„ç†

```typescript
export class FMTCDataProcessor {
  /**
   * äº‹åŠ¡æ€§æ‰¹é‡æ•°æ®å¤„ç†
   */
  async processMerchantDataBatch(
    merchants: FMTCMerchantData[],
    executionId: string,
  ): Promise<BatchProcessResult> {
    return await this.db.$transaction(
      async (tx) => {
        const results: ProcessResult[] = [];

        for (const merchantData of merchants) {
          try {
            // 1. å¹‚ç­‰æ€§æ£€æŸ¥
            const existingRecord = await this.findExistingMerchant(
              tx,
              merchantData,
              executionId,
            );

            if (existingRecord?.processedInExecution === executionId) {
              // å·²å¤„ç†è¿‡ï¼Œè·³è¿‡
              results.push({
                status: "skipped",
                merchantId: merchantData.fmtcId,
              });
              continue;
            }

            // 2. ä¹è§‚é”æ£€æŸ¥
            const currentVersion = existingRecord?.version || 0;

            // 3. æ•°æ®å¤„ç†å’ŒéªŒè¯
            const processedData =
              await this.validateAndTransformData(merchantData);

            // 4. åŸå­æ€§æ›´æ–°
            const result = await this.upsertMerchant(tx, {
              ...processedData,
              version: currentVersion + 1,
              processedInExecution: executionId,
              processedAt: new Date(),
            });

            results.push({ status: "success", merchantId: result.id });
          } catch (error) {
            if (error.code === "P2034") {
              // ä¹è§‚é”å†²çªï¼Œé‡è¯•
              results.push({
                status: "retry",
                merchantId: merchantData.fmtcId,
              });
            } else {
              // å…¶ä»–é”™è¯¯ï¼Œè®°å½•å¹¶ç»§ç»­
              results.push({
                status: "error",
                merchantId: merchantData.fmtcId,
                error: error.message,
              });
            }
          }
        }

        return {
          total: merchants.length,
          successful: results.filter((r) => r.status === "success").length,
          failed: results.filter((r) => r.status === "error").length,
          skipped: results.filter((r) => r.status === "skipped").length,
          retry: results.filter((r) => r.status === "retry").length,
          results,
        };
      },
      {
        timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
        isolationLevel: "ReadCommitted",
      },
    );
  }

  /**
   * å¹‚ç­‰æ€§å•†æˆ·æŸ¥æ‰¾
   */
  private async findExistingMerchant(
    tx: TransactionClient,
    merchantData: FMTCMerchantData,
    executionId: string,
  ): Promise<ExistingMerchant | null> {
    // ä½¿ç”¨å¤šä¸ªç»´åº¦è¿›è¡Œå”¯ä¸€æ€§åŒ¹é…ï¼Œæé«˜å‡†ç¡®æ€§
    return await tx.fMTCMerchant.findFirst({
      where: {
        OR: [
          // ç²¾ç¡®åŒ¹é…ï¼šFMTC ID
          merchantData.fmtcId ? { fmtcId: merchantData.fmtcId } : {},

          // æ¨¡ç³ŠåŒ¹é…ï¼šåç§° + ä¸»é¡µ
          {
            AND: [
              { name: { equals: merchantData.name, mode: "insensitive" } },
              merchantData.homepage ? { homepage: merchantData.homepage } : {},
            ],
          },

          // å¤‡ç”¨åŒ¹é…ï¼šæºURL
          merchantData.sourceUrl ? { sourceUrl: merchantData.sourceUrl } : {},
        ].filter((condition) => Object.keys(condition).length > 0),
      },
      select: {
        id: true,
        version: true,
        processedInExecution: true,
        lastScrapedAt: true,
      },
    });
  }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### âš¡ æ‰¹é‡å¤„ç†æ€§èƒ½ä¼˜åŒ–

#### æ€§èƒ½ç“¶é¢ˆåˆ†æ

é€šè¿‡æ€§èƒ½åˆ†æå·¥å…·è¯†åˆ«çš„ä¸»è¦ç“¶é¢ˆï¼š

1. **æµè§ˆå™¨å¯åŠ¨å¼€é”€**: æ¯æ¬¡å¯åŠ¨Chromiumæ¶ˆè€—2-3ç§’
2. **ç™»å½•è®¤è¯å»¶è¿Ÿ**: reCAPTCHAå¤„ç†å¹³å‡15-30ç§’
3. **é¡µé¢åŠ è½½ç­‰å¾…**: ç½‘ç»œå»¶è¿Ÿå’ŒDOMæ¸²æŸ“
4. **æ•°æ®åº“I/O**: é¢‘ç¹çš„å•æ¡æ’å…¥/æ›´æ–°æ“ä½œ
5. **å†…å­˜æ³„æ¼**: é•¿æ—¶é—´è¿è¡Œå¯¼è‡´çš„å†…å­˜ç§¯ç´¯

#### ä¼˜åŒ–ç­–ç•¥å®ç°

```typescript
export class PerformanceOptimizedBatchScraper {
  private browserPool: BrowserPool;
  private connectionPool: DatabasePool;
  private memoryMonitor: MemoryMonitor;

  constructor(options: OptimizedScrapingOptions) {
    // 1. æµè§ˆå™¨å®ä¾‹æ± åŒ–
    this.browserPool = new BrowserPool({
      maxInstances: 3,
      warmupInstances: 1,
      instanceTTL: 30 * 60 * 1000, // 30åˆ†é’Ÿ
      launchOptions: {
        headless: true,
        args: [
          "--no-sandbox",
          "--disable-setuid-sandbox",
          "--disable-dev-shm-usage",
          "--disable-web-security",
          "--disable-features=VizDisplayCompositor",
          "--disable-blink-features=AutomationControlled",
          // æ€§èƒ½ä¼˜åŒ–å‚æ•°
          "--memory-pressure-off",
          "--disk-cache-size=0",
          "--media-cache-size=0",
          "--aggressive-cache-discard",
          "--disable-background-timer-throttling",
          "--disable-renderer-backgrounding",
          "--disable-backgrounding-occluded-windows",
        ],
      },
    });

    // 2. æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
    this.connectionPool = new DatabasePool({
      max: 10,
      min: 2,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 200,
    });

    // 3. å†…å­˜ç›‘æ§
    this.memoryMonitor = new MemoryMonitor({
      maxMemoryUsage: 2 * 1024 * 1024 * 1024, // 2GB
      checkInterval: 30000, // 30ç§’
      onMemoryWarning: () => this.handleMemoryPressure(),
      onMemoryError: () => this.handleMemoryError(),
    });
  }

  /**
   * é«˜æ€§èƒ½æ‰¹é‡æŠ“å–å®ç°
   */
  async executeBatchScraping(): Promise<BatchScrapingResult> {
    const performanceTracker = new PerformanceTracker();

    try {
      // 1. é¢„çƒ­å’Œèµ„æºå‡†å¤‡
      await this.warmupResources();

      // 2. æ™ºèƒ½ä»»åŠ¡åˆ†ç‰‡
      const taskChunks = this.createOptimalTaskChunks();

      // 3. å¹¶å‘æ‰§è¡Œæ§åˆ¶
      const concurrencyController = new ConcurrencyController({
        maxConcurrency: this.calculateOptimalConcurrency(),
        rateLimitStrategy: "adaptive",
        backoffMultiplier: 1.5,
      });

      // 4. æ‰¹é‡å¤„ç†å¾ªç¯
      let totalResults: BatchResult[] = [];

      for (const chunk of taskChunks) {
        const chunkResults = await concurrencyController.execute(
          chunk.map((task) => () => this.processTaskOptimized(task)),
        );

        totalResults = totalResults.concat(chunkResults);

        // 5. å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶
        await this.performMaintenanceTasks();

        // 6. è‡ªé€‚åº”å»¶è¿Ÿ
        await this.adaptiveDelay(chunkResults);
      }

      return this.aggregateResults(totalResults);
    } finally {
      await this.cleanup();
      performanceTracker.report();
    }
  }

  /**
   * æ™ºèƒ½ä»»åŠ¡åˆ†ç‰‡ç®—æ³•
   */
  private createOptimalTaskChunks(): MerchantTask[][] {
    const tasks = Array.from(this.tasks.values());
    const totalTasks = tasks.length;

    // 1. æ ¹æ®å†å²æ€§èƒ½æ•°æ®ä¼°ç®—æœ€ä¼˜åˆ†ç‰‡å¤§å°
    const avgTaskDuration = this.getAverageTaskDuration();
    const targetChunkDuration = 5 * 60 * 1000; // 5åˆ†é’Ÿ
    const optimalChunkSize = Math.max(
      1,
      Math.floor(targetChunkDuration / avgTaskDuration),
    );

    // 2. è€ƒè™‘å†…å­˜é™åˆ¶
    const memoryBasedChunkSize = this.calculateMemoryBasedChunkSize();
    const chunkSize = Math.min(optimalChunkSize, memoryBasedChunkSize);

    // 3. åˆ›å»ºå¹³è¡¡çš„åˆ†ç‰‡
    const chunks: MerchantTask[][] = [];
    for (let i = 0; i < totalTasks; i += chunkSize) {
      chunks.push(tasks.slice(i, i + chunkSize));
    }

    return chunks;
  }

  /**
   * è‡ªé€‚åº”å¹¶å‘æ§åˆ¶
   */
  private calculateOptimalConcurrency(): number {
    const systemLoad = this.getSystemLoad();
    const networkLatency = this.getNetworkLatency();
    const memoryPressure = this.getMemoryPressure();

    // åŸºç¡€å¹¶å‘æ•°
    let concurrency = 3;

    // æ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´
    if (systemLoad > 0.8) {
      concurrency = Math.max(1, concurrency - 1);
    } else if (systemLoad < 0.3) {
      concurrency = Math.min(5, concurrency + 1);
    }

    // æ ¹æ®ç½‘ç»œå»¶è¿Ÿè°ƒæ•´
    if (networkLatency > 2000) {
      // 2ç§’ä»¥ä¸Š
      concurrency = Math.max(1, concurrency - 1);
    }

    // æ ¹æ®å†…å­˜å‹åŠ›è°ƒæ•´
    if (memoryPressure > 0.85) {
      concurrency = Math.max(1, Math.floor(concurrency / 2));
    }

    return concurrency;
  }

  /**
   * å†…å­˜å‹åŠ›å¤„ç†
   */
  private async handleMemoryPressure(): Promise<void> {
    // 1. å¼ºåˆ¶åƒåœ¾å›æ”¶
    if (global.gc) {
      global.gc();
    }

    // 2. æ¸…ç†ä¸å¿…è¦çš„ç¼“å­˜
    await this.clearInternalCaches();

    // 3. å‡å°‘å¹¶å‘æ•°
    this.currentConcurrency = Math.max(
      1,
      Math.floor(this.currentConcurrency / 2),
    );

    // 4. é‡å¯å†…å­˜ä½¿ç”¨è¿‡é«˜çš„æµè§ˆå™¨å®ä¾‹
    await this.browserPool.recycleHighMemoryInstances();

    // 5. å»¶è¿Ÿå¤„ç†ä»¥é™ä½ç³»ç»Ÿå‹åŠ›
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }
}
```

#### æ•°æ®åº“æ‰¹é‡ä¼˜åŒ–

```typescript
export class OptimizedDataProcessor {
  /**
   * æ‰¹é‡upsertä¼˜åŒ–å®ç°
   */
  async batchUpsertMerchants(
    merchants: FMTCMerchantData[],
  ): Promise<BatchUpsertResult> {
    const batchSize = 50; // ç»éªŒè¯çš„æœ€ä¼˜æ‰¹æ¬¡å¤§å°
    const batches = this.chunkArray(merchants, batchSize);

    const results = await Promise.allSettled(
      batches.map(async (batch, index) => {
        return await this.processBatchWithRetry(batch, index);
      }),
    );

    return this.aggregateBatchResults(results);
  }

  /**
   * å•æ‰¹æ¬¡å¤„ç†ä¼˜åŒ–
   */
  private async processBatchWithRetry(
    batch: FMTCMerchantData[],
    batchIndex: number,
    retryCount = 0,
  ): Promise<BatchResult> {
    const maxRetries = 3;

    try {
      // ä½¿ç”¨PostgreSQL UPSERTä¼˜åŒ–
      const query = `
        INSERT INTO "FMTCMerchant" (
          id, name, "fmtcId", country, network, homepage,
          description, "primaryCategory", "logo120x60", 
          networks, "affiliateLinks", "lastScrapedAt",
          "rawData", "createdAt", "updatedAt"
        ) VALUES ${batch.map((_, i) => `($${i * 14 + 1}, $${i * 14 + 2}, $${i * 14 + 3}, $${i * 14 + 4}, $${i * 14 + 5}, $${i * 14 + 6}, $${i * 14 + 7}, $${i * 14 + 8}, $${i * 14 + 9}, $${i * 14 + 10}, $${i * 14 + 11}, $${i * 14 + 12}, $${i * 14 + 13}, $${i * 14 + 14})`).join(", ")}
        ON CONFLICT ("fmtcId") 
        DO UPDATE SET
          name = EXCLUDED.name,
          country = EXCLUDED.country,
          network = EXCLUDED.network,
          homepage = EXCLUDED.homepage,
          description = EXCLUDED.description,
          "primaryCategory" = EXCLUDED."primaryCategory",
          "logo120x60" = EXCLUDED."logo120x60",
          networks = EXCLUDED.networks,
          "affiliateLinks" = EXCLUDED."affiliateLinks",
          "lastScrapedAt" = EXCLUDED."lastScrapedAt",
          "rawData" = EXCLUDED."rawData",
          "updatedAt" = NOW()
        RETURNING id, (xmax = 0) AS inserted;
      `;

      const params = batch.flatMap((merchant) => [
        merchant.id || cuid(),
        merchant.name,
        merchant.fmtcId,
        merchant.country,
        merchant.network,
        merchant.homepage,
        merchant.description,
        merchant.primaryCategory,
        merchant.logo120x60,
        JSON.stringify(merchant.networks || []),
        JSON.stringify(merchant.affiliateLinks || {}),
        new Date(),
        JSON.stringify(merchant),
        new Date(),
      ]);

      const result = await this.db.$queryRawUnsafe(query, ...params);

      return {
        batchIndex,
        processed: batch.length,
        inserted: result.filter((r) => r.inserted).length,
        updated: result.filter((r) => !r.inserted).length,
        errors: [],
      };
    } catch (error) {
      if (retryCount < maxRetries && this.isRetryableError(error)) {
        // æŒ‡æ•°é€€é¿é‡è¯•
        await new Promise((resolve) =>
          setTimeout(resolve, Math.pow(2, retryCount) * 1000),
        );
        return this.processBatchWithRetry(batch, batchIndex, retryCount + 1);
      }

      throw error;
    }
  }
}
```

### ğŸš€ ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### å¤šå±‚æ¬¡ç¼“å­˜æ¶æ„

```typescript
export class MultiLevelCacheManager {
  private l1Cache: LRUCache<string, any>; // å†…å­˜ç¼“å­˜
  private l2Cache: RedisCache; // Redisç¼“å­˜
  private l3Cache: DatabaseCache; // æ•°æ®åº“ç¼“å­˜

  constructor() {
    // L1: å†…å­˜ç¼“å­˜ (æœ€å¿«ï¼Œå®¹é‡å°)
    this.l1Cache = new LRUCache({
      max: 1000,
      ttl: 5 * 60 * 1000, // 5åˆ†é’Ÿ
      updateAgeOnGet: true,
    });

    // L2: Redisç¼“å­˜ (å¿«é€Ÿï¼Œå®¹é‡ä¸­ç­‰)
    this.l2Cache = new RedisCache({
      host: process.env.REDIS_HOST,
      ttl: 30 * 60 * 1000, // 30åˆ†é’Ÿ
      serializer: "json",
    });

    // L3: æ•°æ®åº“ç¼“å­˜ (è¾ƒæ…¢ï¼Œå®¹é‡å¤§)
    this.l3Cache = new DatabaseCache({
      tableName: "cache_entries",
      ttl: 24 * 60 * 60 * 1000, // 24å°æ—¶
    });
  }

  /**
   * æ™ºèƒ½ç¼“å­˜è·å–
   */
  async get<T>(key: string): Promise<T | null> {
    // 1. L1ç¼“å­˜æŸ¥è¯¢
    let value = this.l1Cache.get(key);
    if (value) {
      this.recordCacheHit("L1", key);
      return value;
    }

    // 2. L2ç¼“å­˜æŸ¥è¯¢
    value = await this.l2Cache.get(key);
    if (value) {
      this.recordCacheHit("L2", key);
      // å›å¡«L1ç¼“å­˜
      this.l1Cache.set(key, value);
      return value;
    }

    // 3. L3ç¼“å­˜æŸ¥è¯¢
    value = await this.l3Cache.get(key);
    if (value) {
      this.recordCacheHit("L3", key);
      // å›å¡«ä¸Šå±‚ç¼“å­˜
      this.l1Cache.set(key, value);
      await this.l2Cache.set(key, value);
      return value;
    }

    this.recordCacheMiss(key);
    return null;
  }

  /**
   * æ™ºèƒ½ç¼“å­˜è®¾ç½®
   */
  async set<T>(key: string, value: T, options?: CacheOptions): Promise<void> {
    const size = this.estimateSize(value);
    const importance = options?.importance || "normal";

    // æ ¹æ®æ•°æ®å¤§å°å’Œé‡è¦æ€§å†³å®šç¼“å­˜å±‚çº§
    if (importance === "high" || size < 1024) {
      // 1KBä»¥ä¸‹æˆ–é«˜é‡è¦æ€§
      this.l1Cache.set(key, value);
    }

    if (importance !== "low" && size < 1024 * 1024) {
      // 1MBä»¥ä¸‹ä¸”éä½é‡è¦æ€§
      await this.l2Cache.set(key, value);
    }

    // L3ç¼“å­˜å­˜å‚¨æ‰€æœ‰æ•°æ®
    await this.l3Cache.set(key, value);
  }
}
```

## æ‰©å±•æ€§è®¾è®¡

### ğŸ”Œ æ’ä»¶åŒ–æ¶æ„

#### çˆ¬è™«æ‰©å±•æ¥å£è®¾è®¡

```typescript
// æ ¸å¿ƒçˆ¬è™«æ¥å£
export interface ScraperPlugin {
  readonly name: string;
  readonly version: string;
  readonly supportedSites: string[];

  // ç”Ÿå‘½å‘¨æœŸé’©å­
  initialize(config: PluginConfig): Promise<void>;
  cleanup(): Promise<void>;

  // æ ¸å¿ƒåŠŸèƒ½æ¥å£
  login(credentials: SiteCredentials): Promise<LoginResult>;
  scrapeList(params: ScrapeParams): Promise<ScrapeResult>;
  scrapeDetail(url: string): Promise<DetailResult>;

  // å¯é€‰æ‰©å±•æ¥å£
  validateData?(data: any): Promise<ValidationResult>;
  transformData?(data: any): Promise<any>;
  handleErrors?(error: Error): Promise<ErrorHandlingResult>;
}

// FMTCæ’ä»¶å®ç°
export class FMTCScraperPlugin implements ScraperPlugin {
  readonly name = "fmtc-scraper";
  readonly version = "2.0.0";
  readonly supportedSites = ["fmtc.co", "account.fmtc.co"];

  private loginHandler: FMTCLoginHandler;
  private listHandler: FMTCListHandler;
  private detailHandler: FMTCDetailHandler;

  async initialize(config: PluginConfig): Promise<void> {
    this.loginHandler = new FMTCLoginHandler(config.login);
    this.listHandler = new FMTCListHandler(config.list);
    this.detailHandler = new FMTCDetailHandler(config.detail);

    // éªŒè¯é…ç½®
    await this.validateConfiguration(config);

    // åˆå§‹åŒ–èµ„æº
    await this.setupResources();
  }

  async scrapeList(params: ScrapeParams): Promise<ScrapeResult> {
    // å§”æ‰˜ç»™ä¸“é—¨çš„å¤„ç†å™¨
    return await this.listHandler.scrape(params);
  }

  // æ•°æ®éªŒè¯æ‰©å±•
  async validateData(data: FMTCMerchantData): Promise<ValidationResult> {
    const validator = new FMTCDataValidator();
    return await validator.validate(data);
  }

  // æ•°æ®è½¬æ¢æ‰©å±•
  async transformData(data: FMTCMerchantData): Promise<StandardMerchantData> {
    const transformer = new FMTCDataTransformer();
    return await transformer.transform(data);
  }
}

// æ’ä»¶ç®¡ç†å™¨
export class ScraperPluginManager {
  private plugins = new Map<string, ScraperPlugin>();
  private pluginConfigs = new Map<string, PluginConfig>();

  /**
   * æ³¨å†Œæ’ä»¶
   */
  async registerPlugin(
    plugin: ScraperPlugin,
    config: PluginConfig,
  ): Promise<void> {
    // éªŒè¯æ’ä»¶
    await this.validatePlugin(plugin);

    // åˆå§‹åŒ–æ’ä»¶
    await plugin.initialize(config);

    // å­˜å‚¨æ’ä»¶
    this.plugins.set(plugin.name, plugin);
    this.pluginConfigs.set(plugin.name, config);

    console.log(`æ’ä»¶ ${plugin.name} v${plugin.version} æ³¨å†ŒæˆåŠŸ`);
  }

  /**
   * æ ¹æ®ç«™ç‚¹è·å–æ’ä»¶
   */
  getPluginForSite(siteUrl: string): ScraperPlugin | null {
    const hostname = new URL(siteUrl).hostname;

    for (const plugin of this.plugins.values()) {
      if (plugin.supportedSites.some((site) => hostname.includes(site))) {
        return plugin;
      }
    }

    return null;
  }

  /**
   * æ‰§è¡Œè·¨æ’ä»¶æ“ä½œ
   */
  async executeBatchScraping(
    tasks: Array<{ site: string; params: ScrapeParams }>,
  ): Promise<BatchScrapeResult> {
    const results = await Promise.allSettled(
      tasks.map(async (task) => {
        const plugin = this.getPluginForSite(task.site);
        if (!plugin) {
          throw new Error(`æœªæ‰¾åˆ°æ”¯æŒç«™ç‚¹ ${task.site} çš„æ’ä»¶`);
        }

        return await plugin.scrapeList(task.params);
      }),
    );

    return this.aggregateResults(results);
  }
}
```

#### é…ç½®åŒ–é©±åŠ¨è®¾è®¡

```typescript
// ç«™ç‚¹é…ç½®æ¥å£
export interface SiteConfig {
  name: string;
  baseUrl: string;
  loginConfig: LoginConfig;
  selectors: SelectorConfig;
  antiDetection: AntiDetectionConfig;
  rateLimit: RateLimitConfig;
}

// åŠ¨æ€é…ç½®åŠ è½½å™¨
export class DynamicConfigLoader {
  private configCache = new Map<string, SiteConfig>();
  private configWatchers = new Map<string, fs.FSWatcher>();

  /**
   * ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½é…ç½®
   */
  async loadConfig(siteName: string): Promise<SiteConfig> {
    const configPath = path.join(this.configDir, `${siteName}.json`);

    try {
      const configData = await fs.readFile(configPath, "utf-8");
      const config = JSON.parse(configData);

      // éªŒè¯é…ç½®
      const validatedConfig = await this.validateConfig(config);

      // ç¼“å­˜é…ç½®
      this.configCache.set(siteName, validatedConfig);

      // è®¾ç½®æ–‡ä»¶ç›‘å¬
      this.watchConfigFile(siteName, configPath);

      return validatedConfig;
    } catch (error) {
      throw new Error(`åŠ è½½ç«™ç‚¹é…ç½®å¤±è´¥: ${siteName} - ${error.message}`);
    }
  }

  /**
   * é…ç½®çƒ­é‡è½½
   */
  private watchConfigFile(siteName: string, configPath: string): void {
    if (this.configWatchers.has(siteName)) {
      this.configWatchers.get(siteName)!.close();
    }

    const watcher = fs.watch(configPath, async (eventType) => {
      if (eventType === "change") {
        try {
          console.log(`æ£€æµ‹åˆ°é…ç½®æ–‡ä»¶å˜åŒ–: ${siteName}`);

          // é‡æ–°åŠ è½½é…ç½®
          const newConfig = await this.loadConfig(siteName);

          // é€šçŸ¥ç›¸å…³ç»„ä»¶é…ç½®å˜æ›´
          this.emitConfigChange(siteName, newConfig);
        } catch (error) {
          console.error(`é…ç½®çƒ­é‡è½½å¤±è´¥: ${siteName}`, error);
        }
      }
    });

    this.configWatchers.set(siteName, watcher);
  }
}

// ç¤ºä¾‹ï¼šFMTCç«™ç‚¹é…ç½®
const fmtcConfig: SiteConfig = {
  name: "fmtc",
  baseUrl: "https://account.fmtc.co",

  loginConfig: {
    loginUrl: "/cp/login",
    usernameSelector: 'input[name="username"]',
    passwordSelector: 'input[name="password"]',
    submitSelector: 'button[type="submit"]',
    successIndicator: ".dashboard-header",
    recaptchaConfig: {
      siteKey: "auto-detect",
      apiProvider: "2captcha",
    },
  },

  selectors: {
    merchantList: {
      container: ".merchant-list",
      item: ".merchant-item",
      name: ".merchant-name",
      country: ".merchant-country",
      network: ".merchant-network",
    },

    merchantDetail: {
      container: ".merchant-details",
      description: ".merchant-description",
      homepage: 'a[href*="http"]:not([href*="fmtc.co"])',
      logo: 'img[src*="logo"]',
      networks: ".network-list .network-item",
    },
  },

  antiDetection: {
    userAgents: [
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
    ],
    minDelay: 1000,
    maxDelay: 3000,
    mouseSimulation: true,
    scrollSimulation: true,
  },

  rateLimit: {
    requestsPerMinute: 30,
    burstLimit: 10,
    backoffStrategy: "exponential",
  },
};
```

### ğŸŒ å¤šç«™ç‚¹æ”¯æŒæ¶æ„

```typescript
// ç»Ÿä¸€çš„å¤šç«™ç‚¹ç®¡ç†å™¨
export class MultiSiteScraperManager {
  private sitePlugins = new Map<string, ScraperPlugin>();
  private siteConfigs = new Map<string, SiteConfig>();
  private executionQueue = new PriorityQueue<ScrapeTask>();

  /**
   * æ³¨å†Œæ–°ç«™ç‚¹æ”¯æŒ
   */
  async registerSite(
    siteName: string,
    plugin: ScraperPlugin,
    config: SiteConfig,
  ): Promise<void> {
    // éªŒè¯ç«™ç‚¹é…ç½®
    await this.validateSiteConfig(config);

    // åˆå§‹åŒ–æ’ä»¶
    await plugin.initialize({ siteConfig: config });

    // æ³¨å†Œç«™ç‚¹
    this.sitePlugins.set(siteName, plugin);
    this.siteConfigs.set(siteName, config);

    console.log(`ç«™ç‚¹ ${siteName} æ³¨å†ŒæˆåŠŸ`);
  }

  /**
   * è·¨ç«™ç‚¹æ‰¹é‡æŠ“å–
   */
  async executeCrossSiteBatch(
    tasks: CrossSiteTask[],
  ): Promise<CrossSiteBatchResult> {
    // æŒ‰ç«™ç‚¹åˆ†ç»„ä»»åŠ¡
    const tasksBySite = this.groupTasksBySite(tasks);

    // å¹¶è¡Œæ‰§è¡Œå„ç«™ç‚¹ä»»åŠ¡
    const siteResults = await Promise.allSettled(
      Array.from(tasksBySite.entries()).map(async ([siteName, siteTasks]) => {
        const plugin = this.sitePlugins.get(siteName);
        const config = this.siteConfigs.get(siteName);

        if (!plugin || !config) {
          throw new Error(`ç«™ç‚¹ ${siteName} æœªæ³¨å†Œ`);
        }

        return await plugin.executeBatch(siteTasks);
      }),
    );

    // åˆå¹¶ç»“æœ
    return this.mergeCrossSiteResults(siteResults);
  }

  /**
   * æ™ºèƒ½ç«™ç‚¹è¯†åˆ«
   */
  async identifySite(url: string): Promise<string | null> {
    const hostname = new URL(url).hostname;

    for (const [siteName, plugin] of this.sitePlugins.entries()) {
      if (plugin.supportedSites.some((site) => hostname.includes(site))) {
        return siteName;
      }
    }

    // å°è¯•è‡ªåŠ¨è¯†åˆ«
    return await this.autoIdentifySite(url);
  }

  /**
   * è‡ªåŠ¨ç«™ç‚¹è¯†åˆ«
   */
  private async autoIdentifySite(url: string): Promise<string | null> {
    try {
      // è·å–é¡µé¢ç‰¹å¾
      const pageFeatures = await this.extractPageFeatures(url);

      // ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹è¯†åˆ«
      const prediction = await this.siteClassifier.predict(pageFeatures);

      if (prediction.confidence > 0.8) {
        return prediction.siteName;
      }

      return null;
    } catch (error) {
      console.warn(`è‡ªåŠ¨ç«™ç‚¹è¯†åˆ«å¤±è´¥: ${url}`, error);
      return null;
    }
  }
}
```

## æŠ€æœ¯é€‰å‹åŸç†

### ğŸ¯ çˆ¬è™«å¼•æ“é€‰æ‹©

#### Playwright vs Puppeteer vs Selenium

| å¯¹æ¯”ç»´åº¦       | Playwright            | Puppeteer       | Selenium   | é€‰æ‹©ç†ç”±         |
| -------------- | --------------------- | --------------- | ---------- | ---------------- |
| **æ€§èƒ½**       | â­â­â­â­â­            | â­â­â­â­        | â­â­â­     | Playwrightæœ€å¿«   |
| **ç¨³å®šæ€§**     | â­â­â­â­â­            | â­â­â­â­        | â­â­â­     | Playwrightæœ€ç¨³å®š |
| **æµè§ˆå™¨æ”¯æŒ** | Chrome/Firefox/Safari | ä»…Chrome        | å…¨æµè§ˆå™¨   | è¶³å¤Ÿçš„æµè§ˆå™¨æ”¯æŒ |
| **APIè®¾è®¡**    | ç°ä»£async/await       | ç°ä»£async/await | ä¼ ç»Ÿå›è°ƒ   | å¼€å‘ä½“éªŒæ›´å¥½     |
| **åæ£€æµ‹**     | â­â­â­â­â­            | â­â­â­â­        | â­â­       | å†…ç½®åæ£€æµ‹æœºåˆ¶   |
| **æ–‡æ¡£è´¨é‡**   | â­â­â­â­â­            | â­â­â­â­        | â­â­â­     | æ–‡æ¡£æœ€å®Œå–„       |
| **ç¤¾åŒºæ´»è·ƒåº¦** | â­â­â­â­â­            | â­â­â­â­        | â­â­â­â­â­ | å¾®è½¯ç»´æŠ¤ï¼Œæ´»è·ƒ   |

**æœ€ç»ˆé€‰æ‹©ï¼šPlaywright + Chromium**

ä¸»è¦åŸå› ï¼š

1. **æ€§èƒ½ä¼˜åŠ¿**: å¯åŠ¨é€Ÿåº¦å¿«30%ï¼Œå†…å­˜å ç”¨ä½20%
2. **ç°ä»£åŒ–API**: å®Œå…¨åŸºäºPromiseï¼Œä»£ç æ›´ç®€æ´
3. **å†…ç½®åæ£€æµ‹**: è‡ªåŠ¨å¤„ç†å¤šç§åçˆ¬è™«æ£€æµ‹
4. **è°ƒè¯•å‹å¥½**: æä¾›trace viewerç­‰å…ˆè¿›è°ƒè¯•å·¥å…·
5. **ä¼ä¸šçº§æ”¯æŒ**: å¾®è½¯ç»´æŠ¤ï¼Œé•¿æœŸæ”¯æŒä¿éšœ

### ğŸ—„ï¸ æ•°æ®åº“æŠ€æœ¯é€‰æ‹©

#### PostgreSQL vs MySQL vs MongoDB

```typescript
// æ•°æ®æ¨¡å‹å¤æ‚åº¦åˆ†æ
interface FMTCMerchantData {
  // åŸºç¡€å­—æ®µ (å…³ç³»å‹å‹å¥½)
  id: string;
  name: string;
  country: string;

  // å¤æ‚JSONå­—æ®µ (PostgreSQLä¼˜åŠ¿)
  networks: NetworkInfo[]; // æ•°ç»„ç»“æ„
  affiliateLinks: Record<string, string[]>; // åµŒå¥—å¯¹è±¡
  rawData: any; // åŸå§‹æ•°æ®å¤‡ä»½

  // å…¨æ–‡æœç´¢éœ€æ±‚ (PostgreSQLä¼˜åŠ¿)
  description: string; // éœ€è¦å…¨æ–‡æœç´¢

  // åœ°ç†ä½ç½®æ•°æ® (PostgreSQLä¼˜åŠ¿)
  location?: {
    latitude: number;
    longitude: number;
  };
}
```

**é€‰æ‹©PostgreSQLçš„å…³é”®åŸå› **:

1. **JSONæ”¯æŒ**: åŸç”ŸJSONå­—æ®µç±»å‹ï¼Œæ”¯æŒå¤æ‚æŸ¥è¯¢
2. **å…¨æ–‡æœç´¢**: å†…ç½®å…¨æ–‡æœç´¢ï¼Œæ”¯æŒå¤šè¯­è¨€
3. **äº‹åŠ¡ACID**: å¼ºä¸€è‡´æ€§ä¿è¯æ•°æ®å®Œæ•´æ€§
4. **æ‰©å±•æ€§**: ä¸°å¯Œçš„æ‰©å±•ç”Ÿæ€ï¼Œå¦‚PostGIS
5. **æ€§èƒ½**: åœ¨å¤æ‚æŸ¥è¯¢åœºæ™¯ä¸‹æ€§èƒ½ä¼˜å¼‚

### ğŸ”„ å®æ—¶é€šä¿¡æŠ€æœ¯é€‰æ‹©

#### WebSocket vs Server-Sent Events vs Polling

| æŠ€æœ¯æ–¹æ¡ˆ               | å»¶è¿Ÿ | å¤æ‚åº¦ | æœåŠ¡å™¨èµ„æº | å®¢æˆ·ç«¯å…¼å®¹æ€§ | é€‚ç”¨åœºæ™¯     |
| ---------------------- | ---- | ------ | ---------- | ------------ | ------------ |
| **WebSocket**          | æä½ | é«˜     | ä¸­ç­‰       | è‰¯å¥½         | åŒå‘å®æ—¶é€šä¿¡ |
| **Server-Sent Events** | ä½   | ä½     | ä½         | ä¼˜ç§€         | å•å‘æ¨é€     |
| **Polling**            | é«˜   | ä½     | é«˜         | å®Œç¾         | ç®€å•çŠ¶æ€æŸ¥è¯¢ |

**é€‰æ‹©Server-Sent Eventsçš„åŸå› **:

1. **éœ€æ±‚åŒ¹é…**: çˆ¬è™«è¿›åº¦æ¨é€æ˜¯å•å‘é€šä¿¡
2. **å®ç°ç®€å•**: åŸºäºHTTPï¼Œæ˜“äºè°ƒè¯•å’Œç›‘æ§
3. **è‡ªåŠ¨é‡è¿**: æµè§ˆå™¨åŸç”Ÿæ”¯æŒæ–­çº¿é‡è¿
4. **èµ„æºæ•ˆç‡**: æœåŠ¡å™¨èµ„æºå ç”¨æœ€ä½
5. **é”™è¯¯å¤„ç†**: HTTPçŠ¶æ€ç ä¾¿äºé”™è¯¯å¤„ç†

```typescript
// SSEå®ç°ç®€æ´æ€§å¯¹æ¯”
// WebSocketå®ç°
const ws = new WebSocket("ws://localhost:3001/progress");
ws.onopen = () => {
  /* è¿æ¥å¤„ç† */
};
ws.onmessage = (event) => {
  /* æ¶ˆæ¯å¤„ç† */
};
ws.onerror = (error) => {
  /* é”™è¯¯å¤„ç† */
};
ws.onclose = () => {
  /* é‡è¿é€»è¾‘ */
};

// SSEå®ç° (æ›´ç®€æ´)
const eventSource = new EventSource("/api/progress/123");
eventSource.addEventListener("progress", (event) => {
  const data = JSON.parse(event.data);
  // å¤„ç†è¿›åº¦æ›´æ–°
});
// æµè§ˆå™¨è‡ªåŠ¨å¤„ç†é‡è¿
```

## ç³»ç»Ÿé™åˆ¶ä¸è¾¹ç•Œ

### ğŸš§ æŠ€æœ¯é™åˆ¶

#### 1. æµè§ˆå™¨èµ„æºé™åˆ¶

```typescript
interface BrowserResourceLimits {
  // å†…å­˜é™åˆ¶
  maxMemoryPerTab: number; // 1GB per tab
  maxTotalMemory: number; // 4GB total

  // å¹¶å‘é™åˆ¶
  maxConcurrentTabs: number; // 10 tabs
  maxConcurrentBrowsers: number; // 3 browsers

  // ç½‘ç»œé™åˆ¶
  maxConnectionsPerHost: number; // 6 connections
  maxConcurrentRequests: number; // 50 requests

  // æ—¶é—´é™åˆ¶
  pageLoadTimeout: number; // 30 seconds
  navigationTimeout: number; // 60 seconds
  sessionTimeout: number; // 4 hours
}

const SYSTEM_LIMITS: BrowserResourceLimits = {
  maxMemoryPerTab: 1024 * 1024 * 1024,
  maxTotalMemory: 4 * 1024 * 1024 * 1024,
  maxConcurrentTabs: 10,
  maxConcurrentBrowsers: 3,
  maxConnectionsPerHost: 6,
  maxConcurrentRequests: 50,
  pageLoadTimeout: 30000,
  navigationTimeout: 60000,
  sessionTimeout: 4 * 60 * 60 * 1000,
};
```

#### 2. åçˆ¬è™«æ£€æµ‹è¾¹ç•Œ

```typescript
interface AntiDetectionLimits {
  // è¯·æ±‚é¢‘ç‡é™åˆ¶
  minRequestInterval: number; // æœ€å°è¯·æ±‚é—´éš”
  maxRequestsPerMinute: number; // æ¯åˆ†é’Ÿæœ€å¤§è¯·æ±‚æ•°
  burstRequestLimit: number; // çªå‘è¯·æ±‚é™åˆ¶

  // è¡Œä¸ºæ¨¡å¼é™åˆ¶
  maxConsecutiveRequests: number; // è¿ç»­è¯·æ±‚æ•°é™åˆ¶
  requireUserSimulation: boolean; // æ˜¯å¦éœ€è¦ç”¨æˆ·è¡Œä¸ºæ¨¡æ‹Ÿ

  // ä¼šè¯é™åˆ¶
  maxSessionDuration: number; // æœ€é•¿ä¼šè¯æ—¶é—´
  maxLoginAttempts: number; // æœ€å¤§ç™»å½•å°è¯•æ¬¡æ•°
}

const ANTI_DETECTION_LIMITS: AntiDetectionLimits = {
  minRequestInterval: 500, // 0.5ç§’
  maxRequestsPerMinute: 30, // 30æ¬¡/åˆ†é’Ÿ
  burstRequestLimit: 5, // è¿ç»­5æ¬¡åå¿…é¡»æš‚åœ
  maxConsecutiveRequests: 20, // è¿ç»­20æ¬¡åå¿…é¡»é‡æ–°ç™»å½•
  requireUserSimulation: true, // å¿…é¡»æ¨¡æ‹Ÿç”¨æˆ·è¡Œä¸º
  maxSessionDuration: 4 * 60 * 60 * 1000, // 4å°æ—¶
  maxLoginAttempts: 3, // 3æ¬¡å¤±è´¥åé”å®š
};
```

#### 3. æ•°æ®å¤„ç†é™åˆ¶

```typescript
interface DataProcessingLimits {
  maxBatchSize: number; // æœ€å¤§æ‰¹å¤„ç†å¤§å°
  maxConcurrentQueries: number; // æœ€å¤§å¹¶å‘æŸ¥è¯¢æ•°
  maxTransactionTime: number; // æœ€å¤§äº‹åŠ¡æ—¶é—´
  maxMemoryUsage: number; // æœ€å¤§å†…å­˜ä½¿ç”¨
}

const DATA_LIMITS: DataProcessingLimits = {
  maxBatchSize: 100, // 100æ¡è®°å½•/æ‰¹æ¬¡
  maxConcurrentQueries: 20, // 20ä¸ªå¹¶å‘æŸ¥è¯¢
  maxTransactionTime: 30000, // 30ç§’äº‹åŠ¡è¶…æ—¶
  maxMemoryUsage: 2 * 1024 * 1024 * 1024, // 2GBå†…å­˜é™åˆ¶
};
```

### âš ï¸ ä¸šåŠ¡è¾¹ç•Œ

#### 1. æ•°æ®è´¨é‡è¾¹ç•Œ

```typescript
interface DataQualityBoundaries {
  // å¿…å¡«å­—æ®µéªŒè¯
  requiredFields: string[];

  // æ•°æ®æ ¼å¼éªŒè¯
  fieldValidations: Record<string, ValidationRule>;

  // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
  completenessThreshold: number; // æ•°æ®å®Œæ•´æ€§é˜ˆå€¼

  // é‡å¤æ•°æ®å¤„ç†
  deduplicationStrategy: "strict" | "fuzzy" | "disabled";
}

const FMTC_DATA_BOUNDARIES: DataQualityBoundaries = {
  requiredFields: ["name", "country"],

  fieldValidations: {
    name: { minLength: 2, maxLength: 200 },
    homepage: { pattern: /^https?:\/\/.+/ },
    description: { maxLength: 2000 },
    networks: { maxArrayLength: 50 },
  },

  completenessThreshold: 0.7, // 70%å­—æ®µå¿…é¡»æœ‰å€¼
  deduplicationStrategy: "fuzzy", // æ¨¡ç³ŠåŒ¹é…å»é‡
};
```

#### 2. é”™è¯¯å¤„ç†è¾¹ç•Œ

```typescript
interface ErrorHandlingBoundaries {
  // å¯é‡è¯•é”™è¯¯ç±»å‹
  retryableErrors: string[];

  // æœ€å¤§é‡è¯•æ¬¡æ•°
  maxRetryAttempts: number;

  // æ•…éšœè½¬ç§»ç­–ç•¥
  failoverStrategies: Record<string, FailoverStrategy>;

  // é”™è¯¯ç‡é˜ˆå€¼
  errorRateThreshold: number; // é”™è¯¯ç‡è¶…è¿‡æ­¤å€¼æ—¶åœæ­¢
}

const ERROR_BOUNDARIES: ErrorHandlingBoundaries = {
  retryableErrors: [
    "NETWORK_ERROR",
    "TIMEOUT_ERROR",
    "TEMPORARY_FAILURE",
    "RATE_LIMIT_EXCEEDED",
  ],

  maxRetryAttempts: 3,

  failoverStrategies: {
    LOGIN_FAILURE: "switch_account",
    CAPTCHA_FAILURE: "manual_intervention",
    IP_BLOCKED: "proxy_rotation",
    SYSTEM_OVERLOAD: "scale_down_concurrency",
  },

  errorRateThreshold: 0.1, // 10%é”™è¯¯ç‡
};
```

## å®‰å…¨æ€§è®¾è®¡

### ğŸ” æ•°æ®å®‰å…¨

#### æ•æ„Ÿæ•°æ®åŠ å¯†

```typescript
export class CredentialEncryption {
  private readonly algorithm = "aes-256-gcm";
  private readonly keyDerivationIterations = 100000;

  /**
   * åŠ å¯†ç™»å½•å‡­æ®
   */
  async encryptCredentials(
    credentials: FMTCCredentials,
    masterKey: string,
  ): Promise<EncryptedCredentials> {
    // 1. ç”Ÿæˆéšæœºç›å€¼
    const salt = crypto.randomBytes(32);

    // 2. å¯†é’¥æ´¾ç”Ÿ
    const derivedKey = crypto.pbkdf2Sync(
      masterKey,
      salt,
      this.keyDerivationIterations,
      32,
      "sha256",
    );

    // 3. ç”ŸæˆéšæœºIV
    const iv = crypto.randomBytes(16);

    // 4. åˆ›å»ºåŠ å¯†å™¨
    const cipher = crypto.createCipher(this.algorithm, derivedKey);
    cipher.setAAD(salt); // é™„åŠ è®¤è¯æ•°æ®

    // 5. åŠ å¯†æ•°æ®
    const credentialsJson = JSON.stringify(credentials);
    let encrypted = cipher.update(credentialsJson, "utf8", "hex");
    encrypted += cipher.final("hex");

    // 6. è·å–è®¤è¯æ ‡ç­¾
    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      salt: salt.toString("hex"),
      iv: iv.toString("hex"),
      authTag: authTag.toString("hex"),
      algorithm: this.algorithm,
      iterations: this.keyDerivationIterations,
    };
  }

  /**
   * è§£å¯†ç™»å½•å‡­æ®
   */
  async decryptCredentials(
    encryptedData: EncryptedCredentials,
    masterKey: string,
  ): Promise<FMTCCredentials> {
    try {
      // 1. é‡å»ºå¯†é’¥
      const salt = Buffer.from(encryptedData.salt, "hex");
      const derivedKey = crypto.pbkdf2Sync(
        masterKey,
        salt,
        encryptedData.iterations,
        32,
        "sha256",
      );

      // 2. åˆ›å»ºè§£å¯†å™¨
      const decipher = crypto.createDecipher(
        encryptedData.algorithm,
        derivedKey,
      );
      decipher.setAAD(salt);
      decipher.setAuthTag(Buffer.from(encryptedData.authTag, "hex"));

      // 3. è§£å¯†æ•°æ®
      let decrypted = decipher.update(encryptedData.encrypted, "hex", "utf8");
      decrypted += decipher.final("utf8");

      // 4. è§£æJSON
      return JSON.parse(decrypted);
    } catch (error) {
      throw new Error("å‡­æ®è§£å¯†å¤±è´¥: å¯†é’¥é”™è¯¯æˆ–æ•°æ®æŸå");
    }
  }
}
```

#### è®¿é—®æ§åˆ¶

```typescript
export class AccessControlManager {
  /**
   * åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
   */
  async checkPermission(
    userId: string,
    resource: string,
    action: string,
  ): Promise<boolean> {
    // 1. è·å–ç”¨æˆ·è§’è‰²
    const userRoles = await this.getUserRoles(userId);

    // 2. æ£€æŸ¥è§’è‰²æƒé™
    for (const role of userRoles) {
      const permissions = await this.getRolePermissions(role);

      if (
        permissions.some(
          (p) => p.resource === resource && p.actions.includes(action),
        )
      ) {
        return true;
      }
    }

    return false;
  }

  /**
   * APIå¯†é’¥ç®¡ç†
   */
  async generateApiKey(userId: string, scopes: string[]): Promise<ApiKey> {
    const keyId = crypto.randomUUID();
    const secret = crypto.randomBytes(32).toString("base64");

    // å­˜å‚¨å“ˆå¸Œå€¼è€Œä¸æ˜¯æ˜æ–‡
    const hashedSecret = await bcrypt.hash(secret, 12);

    await this.db.apiKey.create({
      data: {
        id: keyId,
        userId,
        hashedSecret,
        scopes,
        createdAt: new Date(),
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30å¤©
      },
    });

    return {
      keyId,
      secret: `fmtc_${keyId}_${secret}`, // å¸¦å‰ç¼€çš„å®Œæ•´å¯†é’¥
      scopes,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
    };
  }
}
```

### ğŸ›¡ï¸ ç½‘ç»œå®‰å…¨

#### è¯·æ±‚ç­¾åéªŒè¯

```typescript
export class RequestSignatureValidator {
  /**
   * ç”Ÿæˆè¯·æ±‚ç­¾å
   */
  generateSignature(
    method: string,
    url: string,
    body: string,
    timestamp: number,
    apiSecret: string,
  ): string {
    // 1. æ„å»ºç­¾åå­—ç¬¦ä¸²
    const signatureString = `${method}\n${url}\n${body}\n${timestamp}`;

    // 2. ä½¿ç”¨HMAC-SHA256ç­¾å
    const signature = crypto
      .createHmac("sha256", apiSecret)
      .update(signatureString)
      .digest("hex");

    return signature;
  }

  /**
   * éªŒè¯è¯·æ±‚ç­¾å
   */
  async validateRequest(request: Request): Promise<boolean> {
    try {
      // 1. æå–ç­¾åå¤´
      const providedSignature = request.headers.get("X-Signature");
      const timestamp = parseInt(request.headers.get("X-Timestamp") || "0");
      const apiKeyId = request.headers.get("X-API-Key");

      if (!providedSignature || !timestamp || !apiKeyId) {
        return false;
      }

      // 2. æ£€æŸ¥æ—¶é—´æˆ³ (é˜²é‡æ”¾æ”»å‡»)
      const now = Date.now();
      if (Math.abs(now - timestamp) > 300000) {
        // 5åˆ†é’Ÿçª—å£
        return false;
      }

      // 3. è·å–APIå¯†é’¥
      const apiKey = await this.getApiKey(apiKeyId);
      if (!apiKey || apiKey.expiresAt < new Date()) {
        return false;
      }

      // 4. é‡æ–°è®¡ç®—ç­¾å
      const body = await request.text();
      const expectedSignature = this.generateSignature(
        request.method,
        request.url,
        body,
        timestamp,
        apiKey.secret,
      );

      // 5. æ—¶é—´å®‰å…¨æ¯”è¼ƒ
      return crypto.timingSafeEqual(
        Buffer.from(providedSignature, "hex"),
        Buffer.from(expectedSignature, "hex"),
      );
    } catch (error) {
      return false;
    }
  }
}
```

## ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### ğŸ“Š æ€§èƒ½ç›‘æ§

#### ç»¼åˆæŒ‡æ ‡æ”¶é›†

```typescript
export class PerformanceMonitor {
  private metricsCollector: MetricsCollector;
  private alertManager: AlertManager;

  constructor() {
    this.metricsCollector = new MetricsCollector({
      flushInterval: 60000, // 1åˆ†é’Ÿ
      bufferSize: 1000,
    });

    this.alertManager = new AlertManager({
      channels: ["email", "slack", "webhook"],
    });
  }

  /**
   * çˆ¬è™«æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   */
  async collectScrapingMetrics(
    executionId: string,
    metrics: ScrapingMetrics,
  ): Promise<void> {
    // 1. åŸºç¡€æ€§èƒ½æŒ‡æ ‡
    this.metricsCollector.gauge(
      "scraper.execution.duration",
      metrics.duration,
      {
        executionId,
        site: "fmtc",
      },
    );

    this.metricsCollector.counter(
      "scraper.merchants.processed",
      metrics.merchantsProcessed,
      {
        executionId,
        status: "success",
      },
    );

    this.metricsCollector.counter(
      "scraper.merchants.failed",
      metrics.merchantsFailed,
      {
        executionId,
        status: "failed",
      },
    );

    // 2. ååé‡æŒ‡æ ‡
    const throughput = metrics.merchantsProcessed / (metrics.duration / 1000);
    this.metricsCollector.gauge(
      "scraper.throughput.merchants_per_second",
      throughput,
      {
        executionId,
      },
    );

    // 3. é”™è¯¯ç‡æŒ‡æ ‡
    const errorRate =
      metrics.merchantsFailed /
      (metrics.merchantsProcessed + metrics.merchantsFailed);
    this.metricsCollector.gauge("scraper.error_rate", errorRate, {
      executionId,
    });

    // 4. èµ„æºä½¿ç”¨æŒ‡æ ‡
    this.metricsCollector.gauge(
      "scraper.memory.peak_usage",
      metrics.peakMemoryUsage,
      {
        executionId,
      },
    );

    this.metricsCollector.gauge(
      "scraper.cpu.average_usage",
      metrics.averageCpuUsage,
      {
        executionId,
      },
    );

    // 5. æ£€æŸ¥å‘Šè­¦æ¡ä»¶
    await this.checkAlertConditions(metrics);
  }

  /**
   * å®æ—¶æ€§èƒ½ç›‘æ§
   */
  async startRealtimeMonitoring(executionId: string): Promise<void> {
    const monitoringInterval = setInterval(async () => {
      try {
        const systemMetrics = await this.collectSystemMetrics();
        const scraperMetrics = await this.collectScraperMetrics(executionId);

        // å‘é€å®æ—¶æŒ‡æ ‡
        await this.sendRealtimeMetrics({
          system: systemMetrics,
          scraper: scraperMetrics,
          timestamp: new Date(),
        });

        // æ£€æŸ¥èµ„æºå‘Šè­¦
        await this.checkResourceAlerts(systemMetrics);
      } catch (error) {
        console.error("å®æ—¶ç›‘æ§é”™è¯¯:", error);
      }
    }, 10000); // 10ç§’é—´éš”

    // å­˜å‚¨ç›‘æ§å¥æŸ„ä»¥ä¾¿æ¸…ç†
    this.activeMonitors.set(executionId, monitoringInterval);
  }

  /**
   * å‘Šè­¦æ¡ä»¶æ£€æŸ¥
   */
  private async checkAlertConditions(metrics: ScrapingMetrics): Promise<void> {
    const alerts: Alert[] = [];

    // é”™è¯¯ç‡å‘Šè­¦
    const errorRate =
      metrics.merchantsFailed /
      (metrics.merchantsProcessed + metrics.merchantsFailed);
    if (errorRate > 0.1) {
      // 10%é”™è¯¯ç‡
      alerts.push({
        level: "warning",
        type: "high_error_rate",
        message: `çˆ¬è™«é”™è¯¯ç‡è¿‡é«˜: ${(errorRate * 100).toFixed(2)}%`,
        metrics: { errorRate },
      });
    }

    // æ€§èƒ½å‘Šè­¦
    const throughput = metrics.merchantsProcessed / (metrics.duration / 1000);
    if (throughput < 0.5) {
      // ä½äº0.5ä¸ª/ç§’
      alerts.push({
        level: "warning",
        type: "low_throughput",
        message: `çˆ¬è™«ååé‡è¿‡ä½: ${throughput.toFixed(2)} merchants/second`,
        metrics: { throughput },
      });
    }

    // å†…å­˜å‘Šè­¦
    if (metrics.peakMemoryUsage > 3 * 1024 * 1024 * 1024) {
      // 3GB
      alerts.push({
        level: "critical",
        type: "high_memory_usage",
        message: `å†…å­˜ä½¿ç”¨è¿‡é«˜: ${(metrics.peakMemoryUsage / 1024 / 1024 / 1024).toFixed(2)}GB`,
        metrics: { memoryUsage: metrics.peakMemoryUsage },
      });
    }

    // å‘é€å‘Šè­¦
    for (const alert of alerts) {
      await this.alertManager.sendAlert(alert);
    }
  }
}
```

### ğŸ“ˆ ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

```typescript
export class BusinessMetricsCollector {
  /**
   * æ•°æ®è´¨é‡ç›‘æ§
   */
  async monitorDataQuality(
    merchants: FMTCMerchantData[],
  ): Promise<DataQualityReport> {
    const report: DataQualityReport = {
      totalMerchants: merchants.length,
      completenessScore: 0,
      accuracyScore: 0,
      freshnessScore: 0,
      consistencyScore: 0,
      issues: [],
    };

    // 1. å®Œæ•´æ€§è¯„åˆ†
    let completeFields = 0;
    let totalFields = 0;

    for (const merchant of merchants) {
      const fields = [
        "name",
        "country",
        "network",
        "homepage",
        "description",
        "primaryCategory",
      ];

      totalFields += fields.length;
      completeFields += fields.filter(
        (field) =>
          merchant[field] && merchant[field].toString().trim().length > 0,
      ).length;
    }

    report.completenessScore = completeFields / totalFields;

    // 2. å‡†ç¡®æ€§è¯„åˆ† (åŸºäºéªŒè¯è§„åˆ™)
    let validMerchants = 0;
    for (const merchant of merchants) {
      if (this.validateMerchantData(merchant)) {
        validMerchants++;
      } else {
        report.issues.push({
          type: "validation_error",
          merchantId: merchant.fmtcId,
          message: "æ•°æ®éªŒè¯å¤±è´¥",
        });
      }
    }

    report.accuracyScore = validMerchants / merchants.length;

    // 3. æ–°é²œåº¦è¯„åˆ†
    const now = new Date();
    let freshMerchants = 0;
    for (const merchant of merchants) {
      const lastScraped = new Date(merchant.lastScrapedAt || 0);
      const ageHours =
        (now.getTime() - lastScraped.getTime()) / (1000 * 60 * 60);

      if (ageHours <= 24) {
        // 24å°æ—¶å†…ä¸ºæ–°é²œ
        freshMerchants++;
      }
    }

    report.freshnessScore = freshMerchants / merchants.length;

    // 4. ä¸€è‡´æ€§è¯„åˆ† (æ£€æŸ¥é‡å¤æ•°æ®)
    const uniqueNames = new Set(merchants.map((m) => m.name.toLowerCase()));
    report.consistencyScore = uniqueNames.size / merchants.length;

    return report;
  }

  /**
   * ä¸šåŠ¡KPIç›‘æ§
   */
  async collectBusinessKPIs(): Promise<BusinessKPIs> {
    const kpis: BusinessKPIs = {
      // å•†æˆ·æ•°æ®æŒ‡æ ‡
      totalMerchants: await this.db.fMTCMerchant.count(),
      activeMerchants: await this.db.fMTCMerchant.count({
        where: { isActive: true },
      }),

      // å“ç‰ŒåŒ¹é…æŒ‡æ ‡
      brandMatchedMerchants: await this.db.fMTCMerchant.count({
        where: { brandId: { not: null } },
      }),

      // æ•°æ®æ–°é²œåº¦æŒ‡æ ‡
      recentlyUpdatedMerchants: await this.db.fMTCMerchant.count({
        where: {
          lastScrapedAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // 24å°æ—¶å†…
          },
        },
      }),

      // çˆ¬è™«æ‰§è¡ŒæŒ‡æ ‡
      successfulExecutions: await this.db.fMTCScraperExecution.count({
        where: {
          status: "COMPLETED",
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // 7å¤©å†…
          },
        },
      }),

      // é”™è¯¯ç‡æŒ‡æ ‡
      failedExecutions: await this.db.fMTCScraperExecution.count({
        where: {
          status: "FAILED",
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          },
        },
      }),
    };

    // è®¡ç®—è¡ç”ŸæŒ‡æ ‡
    kpis.brandMatchingRate = kpis.brandMatchedMerchants / kpis.totalMerchants;
    kpis.dataFreshnessRate =
      kpis.recentlyUpdatedMerchants / kpis.totalMerchants;
    kpis.scraperSuccessRate =
      kpis.successfulExecutions /
      (kpis.successfulExecutions + kpis.failedExecutions);

    return kpis;
  }
}
```

## å®¹é”™ä¸æ¢å¤æœºåˆ¶

### ğŸ”„ æ•…éšœæ¢å¤ç­–ç•¥

#### åˆ†çº§æ¢å¤æœºåˆ¶

```typescript
export class FaultToleranceManager {
  private recoveryStrategies = new Map<ErrorType, RecoveryStrategy>();

  constructor() {
    this.initializeRecoveryStrategies();
  }

  /**
   * åˆå§‹åŒ–æ¢å¤ç­–ç•¥
   */
  private initializeRecoveryStrategies(): void {
    // Level 1: è½»å¾®é”™è¯¯ - è‡ªåŠ¨é‡è¯•
    this.recoveryStrategies.set("NETWORK_TIMEOUT", {
      level: 1,
      maxRetries: 3,
      backoffMultiplier: 2,
      strategy: "exponential_backoff",
      fallback: null,
    });

    // Level 2: ä¸­ç­‰é”™è¯¯ - é‡è¯• + é™çº§
    this.recoveryStrategies.set("RATE_LIMIT_EXCEEDED", {
      level: 2,
      maxRetries: 2,
      backoffMultiplier: 3,
      strategy: "linear_backoff",
      fallback: "reduce_concurrency",
    });

    // Level 3: ä¸¥é‡é”™è¯¯ - æ•…éšœè½¬ç§»
    this.recoveryStrategies.set("LOGIN_FAILURE", {
      level: 3,
      maxRetries: 1,
      backoffMultiplier: 1,
      strategy: "immediate_failover",
      fallback: "switch_account",
    });

    // Level 4: è‡´å‘½é”™è¯¯ - åœæ­¢å¹¶å‘Šè­¦
    this.recoveryStrategies.set("SYSTEM_OVERLOAD", {
      level: 4,
      maxRetries: 0,
      backoffMultiplier: 1,
      strategy: "graceful_shutdown",
      fallback: "manual_intervention",
    });
  }

  /**
   * æ‰§è¡Œæ•…éšœæ¢å¤
   */
  async executeRecovery(
    error: ScrapingError,
    context: RecoveryContext,
  ): Promise<RecoveryResult> {
    const strategy = this.recoveryStrategies.get(error.type);

    if (!strategy) {
      return { success: false, action: "unknown_error" };
    }

    switch (strategy.level) {
      case 1:
        return await this.handleLevel1Recovery(error, strategy, context);
      case 2:
        return await this.handleLevel2Recovery(error, strategy, context);
      case 3:
        return await this.handleLevel3Recovery(error, strategy, context);
      case 4:
        return await this.handleLevel4Recovery(error, strategy, context);
      default:
        return { success: false, action: "unsupported_level" };
    }
  }

  /**
   * Level 1: è‡ªåŠ¨é‡è¯•æ¢å¤
   */
  private async handleLevel1Recovery(
    error: ScrapingError,
    strategy: RecoveryStrategy,
    context: RecoveryContext,
  ): Promise<RecoveryResult> {
    const attempt = context.retryCount || 0;

    if (attempt >= strategy.maxRetries) {
      return { success: false, action: "max_retries_exceeded" };
    }

    // è®¡ç®—é€€é¿å»¶è¿Ÿ
    const delay = this.calculateBackoffDelay(
      strategy.strategy,
      attempt,
      strategy.backoffMultiplier,
    );

    // ç­‰å¾…å¹¶é‡è¯•
    await new Promise((resolve) => setTimeout(resolve, delay));

    try {
      // é‡æ–°æ‰§è¡ŒåŸæ“ä½œ
      await context.retryOperation();
      return { success: true, action: "retry_successful" };
    } catch (retryError) {
      // é€’å½’å¤„ç†é‡è¯•å¤±è´¥
      return await this.executeRecovery(retryError as ScrapingError, {
        ...context,
        retryCount: attempt + 1,
      });
    }
  }

  /**
   * Level 2: é™çº§æ¢å¤
   */
  private async handleLevel2Recovery(
    error: ScrapingError,
    strategy: RecoveryStrategy,
    context: RecoveryContext,
  ): Promise<RecoveryResult> {
    // å…ˆå°è¯•é‡è¯•
    const retryResult = await this.handleLevel1Recovery(
      error,
      strategy,
      context,
    );

    if (retryResult.success) {
      return retryResult;
    }

    // é‡è¯•å¤±è´¥ï¼Œæ‰§è¡Œé™çº§ç­–ç•¥
    switch (strategy.fallback) {
      case "reduce_concurrency":
        await this.reduceConcurrency(context);
        return { success: true, action: "concurrency_reduced" };

      case "skip_non_essential":
        await this.skipNonEssentialTasks(context);
        return { success: true, action: "tasks_skipped" };

      default:
        return { success: false, action: "fallback_failed" };
    }
  }

  /**
   * Level 3: æ•…éšœè½¬ç§»æ¢å¤
   */
  private async handleLevel3Recovery(
    error: ScrapingError,
    strategy: RecoveryStrategy,
    context: RecoveryContext,
  ): Promise<RecoveryResult> {
    switch (strategy.fallback) {
      case "switch_account":
        const accountSwitched = await this.switchToBackupAccount(context);
        if (accountSwitched) {
          return { success: true, action: "account_switched" };
        }
        break;

      case "switch_proxy":
        const proxySwitched = await this.switchToBackupProxy(context);
        if (proxySwitched) {
          return { success: true, action: "proxy_switched" };
        }
        break;

      case "restart_browser":
        await this.restartBrowserInstance(context);
        return { success: true, action: "browser_restarted" };
    }

    return { success: false, action: "failover_exhausted" };
  }

  /**
   * Level 4: ä¼˜é›…å…³é—­
   */
  private async handleLevel4Recovery(
    error: ScrapingError,
    strategy: RecoveryStrategy,
    context: RecoveryContext,
  ): Promise<RecoveryResult> {
    // å‘é€ç´§æ€¥å‘Šè­¦
    await this.sendCriticalAlert(error, context);

    // ä¿å­˜å½“å‰çŠ¶æ€
    await this.saveRecoveryCheckpoint(context);

    // ä¼˜é›…å…³é—­
    await this.gracefulShutdown(context);

    return { success: false, action: "system_shutdown" };
  }
}
```

#### æ•°æ®ä¸€è‡´æ€§æ¢å¤

```typescript
export class DataConsistencyRecovery {
  /**
   * æ£€æµ‹å¹¶ä¿®å¤æ•°æ®ä¸ä¸€è‡´
   */
  async detectAndRepairInconsistencies(): Promise<RepairReport> {
    const report: RepairReport = {
      totalChecked: 0,
      inconsistenciesFound: 0,
      repairsAttempted: 0,
      repairsSuccessful: 0,
      issues: [],
    };

    // 1. æ£€æŸ¥é‡å¤æ•°æ®
    const duplicates = await this.findDuplicateMerchants();
    report.inconsistenciesFound += duplicates.length;

    for (const duplicate of duplicates) {
      try {
        await this.mergeDuplicateMerchants(duplicate);
        report.repairsSuccessful++;
      } catch (error) {
        report.issues.push({
          type: "duplicate_merge_failed",
          merchantId: duplicate.id,
          error: error.message,
        });
      }
      report.repairsAttempted++;
    }

    // 2. æ£€æŸ¥å­¤å„¿æ•°æ®
    const orphans = await this.findOrphanedRecords();
    report.inconsistenciesFound += orphans.length;

    for (const orphan of orphans) {
      try {
        await this.repairOrphanedRecord(orphan);
        report.repairsSuccessful++;
      } catch (error) {
        report.issues.push({
          type: "orphan_repair_failed",
          recordId: orphan.id,
          error: error.message,
        });
      }
      report.repairsAttempted++;
    }

    // 3. æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
    const integrityIssues = await this.checkDataIntegrity();
    report.inconsistenciesFound += integrityIssues.length;

    for (const issue of integrityIssues) {
      try {
        await this.repairIntegrityIssue(issue);
        report.repairsSuccessful++;
      } catch (error) {
        report.issues.push({
          type: "integrity_repair_failed",
          issueId: issue.id,
          error: error.message,
        });
      }
      report.repairsAttempted++;
    }

    return report;
  }

  /**
   * åˆ›å»ºæ•°æ®æ¢å¤ç‚¹
   */
  async createRecoveryCheckpoint(
    executionId: string,
    state: ScrapingState,
  ): Promise<string> {
    const checkpointId = crypto.randomUUID();

    const checkpoint: RecoveryCheckpoint = {
      id: checkpointId,
      executionId,
      timestamp: new Date(),
      state: {
        completedTasks: state.completedTasks.map((t) => t.id),
        failedTasks: state.failedTasks.map((t) => t.id),
        pendingTasks: state.pendingTasks.map((t) => t.id),
        currentPosition: state.currentPosition,
        sessionData: state.sessionData,
        configuration: state.configuration,
      },
      checksum: this.calculateStateChecksum(state),
    };

    // ä¿å­˜åˆ°æ•°æ®åº“å’Œæ–‡ä»¶ç³»ç»Ÿ
    await Promise.all([
      this.db.recoveryCheckpoint.create({ data: checkpoint }),
      this.saveCheckpointToFile(checkpointId, checkpoint),
    ]);

    return checkpointId;
  }

  /**
   * ä»æ¢å¤ç‚¹æ¢å¤
   */
  async restoreFromCheckpoint(checkpointId: string): Promise<ScrapingState> {
    try {
      // ä»æ•°æ®åº“åŠ è½½
      const checkpoint = await this.db.recoveryCheckpoint.findUnique({
        where: { id: checkpointId },
      });

      if (!checkpoint) {
        throw new Error(`æ¢å¤ç‚¹ä¸å­˜åœ¨: ${checkpointId}`);
      }

      // éªŒè¯æ£€æŸ¥ç‚¹å®Œæ•´æ€§
      const isValid = await this.validateCheckpoint(checkpoint);
      if (!isValid) {
        throw new Error(`æ¢å¤ç‚¹æ•°æ®æŸå: ${checkpointId}`);
      }

      // é‡å»ºçŠ¶æ€
      const restoredState = await this.rebuildScrapingState(checkpoint.state);

      console.log(`æˆåŠŸä»æ¢å¤ç‚¹æ¢å¤: ${checkpointId}`);
      return restoredState;
    } catch (error) {
      console.error(`æ¢å¤ç‚¹æ¢å¤å¤±è´¥: ${checkpointId}`, error);
      throw error;
    }
  }
}
```

è¿™ä¸ªæ¶æ„æ·±åº¦åˆ†ææ–‡æ¡£æä¾›äº†FMTCçˆ¬è™«ç³»ç»Ÿè®¾è®¡å†³ç­–çš„æ·±å±‚æ¬¡æ€è€ƒï¼ŒåŒ…æ‹¬æŠ€æœ¯é€‰å‹åŸç†ã€æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ã€æ‰©å±•æ€§è®¾è®¡å’Œå®¹é”™æœºåˆ¶ç­‰å…³é”®æ¶æ„è¦ç´ ã€‚é€šè¿‡è¿™äº›åˆ†æï¼Œå¼€å‘è€…å¯ä»¥æ›´æ·±å…¥åœ°ç†è§£ç³»ç»Ÿçš„è®¾è®¡ç†å¿µå’Œå®ç°ç»†èŠ‚ã€‚
